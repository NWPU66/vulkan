# Vulkan 起源

Vulkan 是作为一个跨平台的图形 API 设计的。以往许多图形 API 采用固定功能渲染管线设计，应用程序按照一定格式提交顶点数据，配置光照和着色选项。

随着显卡架构逐渐成熟，提供了越来越多的可编程功能，这些功能被集成到原有的 API 中。造成驱动程序要做的工作越来越复杂，应用程序开发者要处理的兼容性问题也越来越多。随着移动浪潮到来，人们对移动 GPU 的要求也越来越高，但以往的图形 API 不能够进行更加精准地控制来提升效率，对多线程的支持也非常不足，导致没有发挥出图形硬件真正的潜力。

由于没有历史包袱，Vulkan 完全按照现代图形架构设计，提供了更加详细的 API 给开发者，大大减少了驱动程序的开销，允许多个线程并行创建和提交指令，使用标准化的着色器字节码，将图形和计算功能进行统一。

# 绘制一个三角形

1. 实例、物理设备
2. 逻辑设备、队列族
   我们需要使用更详细的 VkPhysicalDevice 特性(比如多视口，64 位浮点)来创建一个逻辑设备 VkDevice。
   还需要指定我们想要使用的队列族。Vulkan 将诸如绘制指令、内存操作提交到 VkQueue 中，进行异步执行。队列由队列族分配，每个队列族支持一个特定操作集合。比如，图形，计算和内存传输操作可以使用独立的队列族。
   队列族可以作为物理设备选择时的一个参考。比如，一个支持 Vulkan 的设备可能没有提供任何图形功能，但对于支持 Vulkan 的显卡设备而言，支持所有队列操作。
3. 窗口表面和交换链
   我们还需要两个组件才能完成窗口渲染：窗口表面(VkSurfaceKHR)和交换链(VkSwapChainKHR)。
   可以注意到这两个组件都有一个 KHR 后缀，这表示它们属于 Vulkan 扩展。Vulkan API 本身是完全平台无关的，需要我们使用 WSI(Window System Interface，窗口系统接口)扩展与原生的窗口管理器进行交互。
   表面(Surface)是一个跨平台抽象，通常它是由原生窗口系统句柄作为参数实例化得到。不过，这一部分工作，GLFW 已经帮我们处理了，所以不用我们关心。

   交换链是一个渲染目标集合。它可以保证我们正在渲染的图像和当前屏幕图像是两个不同的图像。这可以确保显示出来的图像是完整的。
   每次绘制一帧时，可以请求交换链提供一张图像。绘制完成后，图像被返回到交换链中，在之后某个时刻，图像被显示到屏幕上。
   渲染目标数量和图像显示到屏幕的时机依赖于显示模式。常用的显示模式有双缓冲(vsync，垂直同步)和三缓冲。我们将在创建交换链章节讨论这些问题。

4. 图像视图和帧缓冲
   从交换链获取图像后，还不能直接在图像上进行绘制，需要将图像先包装进 VkImageView 和 VkFramebuffer 中去。一个图像视图可以引用图像的特定部分，一个帧缓冲可以引用图像视图作为颜色，深度和模板目标。交换链中可能有多个不同的图像，我们可以预先为它们每一个都创建好图像视图和帧缓冲，然后在绘制时选择对应的那个。
5. 渲染流程
   渲染流程描述了渲染操作使用的图像类型，图像的使用方式，图像的内容如何处理。对于我们这个绘制三角形的程序，我们使用了一张图像作为颜色目标，在执行绘制操作前清除整个图像。
   渲染流程只描述了图像的类型，图像绑定是通过 VkFramebuffer 完成的。
6. 图形管线
   Vulkan 的图形管线可以通过 VkPipeline 对象建立。它描述了显卡的可配置状态，比如视口大小和深度缓冲操作，以及使用 VkShaderModule 对象的可编程状态。VkShaderModule 对象由着色器字节码创建而来。驱动程序知道哪些渲染目标被图形管线使用。

   Vulkan 与之前的图形 API 的一个最大不同是几乎所有图形管线的配置都需要提前完成。这意味着如果我们想要使用另外一个着色器或者顶点布局，需要重新创建整个图形管线。
   显然效率很低，这迫使我们提前创建出所有我们需要的图形管线，在需要时直接使用已经创建好的图形管线。图形管线只有很少一部分配置可以动态修改，比如视口大小和清除颜色。图形管线的所有状态也需要显式地描述，比如，不存在默认的颜色混合状态。

   这样做的好处类似于预编译相比于即时编译，驱动程序可以有更大的优化空间，并且以图形管线为切换单位，渲染效果的预期也变得十分容易，不用担心切换时，遗漏某个微小的设置，造成结果的巨大差异。

7. 指令池和指令缓冲
   之前提到，Vulkan 的许多操作需要提交到队列才能执行。这些操作首先被记录到一个 VkCommandBuffer 对象中，然后提交给队列。VkCommandBuffer 对象由一个关联了特定队列族的 VkCommandPool 分配而来。

   由于帧缓冲绑定的图像依赖于交换链给我们的图像，我们可以提前为每个图像建立指令缓冲，然后在绘制时，直接选择对应的指令缓冲使用。当然在每一帧记录指令缓冲也是可以的，但这样做效率很低。

8. 主循环
   将绘制指令包装进指令缓冲后，主循环变得非常直白。我们首先使用 vkAcquireNextImageKHR 函数从交换链获取一张图像。接着使用 vkQueueSubmit 函数提交图像对应的指令缓冲。最后，使用 vkQueuePresentKHR 函数将图像返回给交换链，显示图像到屏幕。

   提交给队列的操作会被异步执行。我们需要采取同步措施比如信号量来确保操作按正确的顺序执行。
   绘制指令的执行必须在获取图像之后，否则，可能会出现读写冲突，屏幕正在读取图像数据的同时，绘制操作在进行绘制操作，造成屏幕读取显示的数据并非来自同一帧。
   同样，vkQueuePresentKHR 函数调用需要在绘制完成后进行。

# 总结

对于绘制一个三角形，我们需要采取的步骤包括：

- 创建一个 VkInstance
- 选择一个支持 Vulkan 的图形设备(VkPhysicalDevice)
- 为绘制和显示操作创建 VkDevice 和 VkQueue
- 创建一个窗口，窗口表面和交换链
- 将交换链图像包装进 VkImageView
- 创建一个渲染层指定渲染目标和使用方式
- 为渲染层创建帧缓冲
- 配置图形管线
- 为每一个交换链图像分配指令缓冲
- 从交换链获取图像进行绘制操作，提交图像对应的指令缓冲，返回图像到交换链

# Vulkan API

## 编码约定

Vulkan API 的函数都带有一个小写的 vk 前缀，枚举和结构体名带有一个 Vk 前缀，枚举值带有一个 VK\_前缀。Vulkan 对结构体非常依赖，大量函数的参数由结构体提供。比如，Vulkan 创建对象的一般形式如下：

```cpp
VkXXXCreateInfo createInfo = {};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
std::cerr << "failed to create object" << std::endl;
return false;
}
```

Vulkan 的许多结构体需要我们通过设置 sType 成员变量来显式指定结构体类型。结构体的 pNext 成员可以指向一个扩展的结构体，在本教程，我们不使用它，它被设置为 nullptr。Vulkan 中创建和销毁对象的函数都有一个 VkAllocationCallbacks 参数，可以被用来自定义内存分配器，在这里，我们不使用它，将其设置为 nullptr。

几乎所有 Vulkan 都会返回一个 VkResult 来表示调用的执行情况，它的值要么是 VK_SUCCESS，要么是一个错误代码。Vulkan 规范文档描述了这些函数返回的错误代码的意义。

# 校验层

之前提到，Vulkan 的设计目标是高性能、低驱动程序开销。所以，默认情况下，它提供的错误检测和调试功能非常有限。驱动程序会在发生错误时直接崩溃，而不是返回一个错误代码。这可能导致对于某种显卡可以工作，不会崩溃，但对于其它显卡无法工作，驱动程序崩溃。

可以通过 Vulkan 的校验层(Validation layers)特性来进行一定的错误检查措施。校验层是一段被插入在 Vulkan API 和驱动程序之间的代码，可以对 Vulkan API 函数的参数进行检查，跟踪内存分配。我们可以在开发期开启校验层，然后在发布程序时关闭校验层，减少性能损失。校验层可以完全自己编写，但为了方便，我们的教程直接使用了 Vulkan SDK 提供的一组校验层。我们通过注册的回调函数来接受来自校验层的调试信息。

由于 Vulkan 的每个操作都要显式定义，加之校验层的使用，调试使用 Vulkan 的程序要比调试使用 OpenGL 和 Direct3D 的程序轻松太多。
